add new version

# --------------
# Please enter the commit message for your changes. Everything below
# this paragraph is ignored, and an empty message aborts the commit.
# Just close the window to accept your message.
diff --git a/cryptozombie-lessons_ru/ru/1/00-overview.md b/cryptozombie-lessons_ru/ru/1/00-overview.md
index 208e332..36cf1cc 100644
--- a/cryptozombie-lessons_ru/ru/1/00-overview.md
+++ b/cryptozombie-lessons_ru/ru/1/00-overview.md
@@ -4,8 +4,8 @@ header: Смелей, человек!
 roadmap: roadmap.jpg
 ---
 
-Как думаешь, всё ли у тебя есть для того, чтобы стать **КриптоЗомби**?
+Всё ли у тебя есть для того, чтобы стать **КриптоЗомби**?
 
-Этот курс научит тебя, как **создать игру на Ethereum**.
+На этом курсе ты научишься, как **создать игру на Ethereum**.
 
-Курс для новичков в Ethereum, но надеемся, что ты уже программировал на других языках (например, на Javascript).
+Курс для новичков в Ethereum, но надеемся, что у тебя есть опыт программирования на других языках (например, на Javascript).
diff --git a/cryptozombie-lessons_ru/ru/1/arrays.md b/cryptozombie-lessons_ru/ru/1/arrays.md
index f730dc5..c803136 100644
--- a/cryptozombie-lessons_ru/ru/1/arrays.md
+++ b/cryptozombie-lessons_ru/ru/1/arrays.md
@@ -70,6 +70,6 @@ Person[] public people;
 
 # Проверь себя
 
-Армию зомби надо где-то хранить. Мы хотим, чтобы другие приложения видели зомби, поэтому сделаем массив открытым.
+Армию зомби надо где-то разместить. Мы хотим, чтобы другие приложения видели зомби, поэтому сделаем массив открытым.
 
 1. Создай открытый массив **_структур_** `Zombie` и назови его `zombies`.
diff --git a/cryptozombie-lessons_ru/ru/1/arraysstructs2.md b/cryptozombie-lessons_ru/ru/1/arraysstructs2.md
index 6d52619..6ae0ca4 100644
--- a/cryptozombie-lessons_ru/ru/1/arraysstructs2.md
+++ b/cryptozombie-lessons_ru/ru/1/arraysstructs2.md
@@ -76,7 +76,7 @@ people.push(satoshi);
 people.push(Person(16, "Vitalik"));
 ```
 
-Обрати внимание, что `array.push()` обозначает как-то конец массива, поэтому элементы выстраиваются по порядку по мере их добавления. Пример: 
+Обрати внимание, что `array.push()` обозначает конец массива, поэтому элементы выстраиваются в порядке добавления. Пример: 
 
 ```
 uint[] numbers;
diff --git a/cryptozombie-lessons_ru/ru/1/contracts.md b/cryptozombie-lessons_ru/ru/1/contracts.md
index 2cb226c..b0c52d6 100644
--- a/cryptozombie-lessons_ru/ru/1/contracts.md
+++ b/cryptozombie-lessons_ru/ru/1/contracts.md
@@ -35,7 +35,7 @@ contract HelloWorld {
 
 Вот так: `pragma solidity ^0.4.19;` (на момент написания кода используется версия Solidity 0.4.19).
 
-Соберем все вместе и получим скелет будущего контракта. Ты будешь начинать с него каждый раз, когда создаешь новый проект:
+Соберем все вместе и получим скелет будущего контракта. Ты будешь начинать с этого каждый раз, когда создаешь новый проект:
 
 ```
 pragma solidity ^0.4.19;
diff --git a/cryptozombie-lessons_ru/ru/1/functions3.md b/cryptozombie-lessons_ru/ru/1/functions3.md
index 83906b7..89c2c7f 100644
--- a/cryptozombie-lessons_ru/ru/1/functions3.md
+++ b/cryptozombie-lessons_ru/ru/1/functions3.md
@@ -87,7 +87,7 @@ function _multiply(uint a, uint b) private pure returns (uint) {
 }
 ```
 
-Функция даже не читает состояние приложения - она возвращает значение, которое зависит только от параметров самой функции. В этом случаем мы задаем функцию как **_pure_**. 
+Функция даже не читает состояние приложения - она возвращает значение, которое зависит только от параметров самой функции. В этом случае мы задаем функцию как **_pure_**. 
 
 > Обрати внимание: не всегда легко вспомнить, когда задать «чистую» функцию или «просмотр». К счастью, компилятор Solidity исправно выдает предупреждения, что нужно использовать тот или иной модификатор. 
 
diff --git a/cryptozombie-lessons_ru/ru/1/keccak256.md b/cryptozombie-lessons_ru/ru/1/keccak256.md
index b6b2d4e..6c550bb 100644
--- a/cryptozombie-lessons_ru/ru/1/keccak256.md
+++ b/cryptozombie-lessons_ru/ru/1/keccak256.md
@@ -73,7 +73,7 @@ keccak256("aaaac");
 
 Как видишь, функция возвращает абсолютно другое значение, хотя мы изменили всего одну входную цифру. 
 
-> Обрати внимание: в блокчейне остро стоит проблема генерации **безопасных** случайных чисел. Приведенный нами метод небезопасен, нодля текущей задачи годится, поскольку безопасность не входит в приоритетные задачи ДНК зомби. 
+> Обрати внимание: в блокчейне остро стоит проблема генерации **безопасных** случайных чисел. Приведенный нами метод небезопасен, но для текущей задачи годится, поскольку безопасность не входит в приоритетные задачи ДНК зомби. 
 
 ## Преобразование типов данных
 
diff --git a/cryptozombie-lessons_ru/ru/1/lessoncomplete.md b/cryptozombie-lessons_ru/ru/1/lessoncomplete.md
index af938f8..f8c842d 100644
--- a/cryptozombie-lessons_ru/ru/1/lessoncomplete.md
+++ b/cryptozombie-lessons_ru/ru/1/lessoncomplete.md
@@ -6,16 +6,16 @@ material:
     answer: 1
 ---
 
-Поздравляем! Вы завершили начальный урок и создали первого зомби-солдата для своей армии.
+Поздравляем! Первый раздел завершен. У тебя есть первый зомби-солдат для будущей армии!
 
 # Следующий шаг
 
-Вы в самом начале пути. Каждую неделю вас будет ждать новый урок КриптоЗомби. С развитием игры вырастет и ваша зомби-армия!
+Ты в самом начале пути. Каждую неделю тебя будет ждать новый урок КриптоЗомби. С развитием игры вырастет и зомби-армия!
 
-### 1. Войдите, чтобы сохранить прогресс
+### 1. Войди, чтобы сохранить прогресс
 
-**_Войдите_** и нажмите «Сохранить прогресс» вверху страницы. Как только появится новый урок, мы сразу дадим вам знать. 
+**_Войди_** и нажми «Сохранить прогресс» вверху страницы. Как только появится новый урок, мы сразу дадим тебе знать. 
 
-### 2. Поделитесь зомби с друзьями
+### 2. Поделись зомби с друзьями
 
 **_Поделиться_** зомби в Твитере и все такое (Вставить изображение / ссылку) 
diff --git a/cryptozombie-lessons_ru/ru/1/lessonoverview.md b/cryptozombie-lessons_ru/ru/1/lessonoverview.md
index f5b2810..8a03292 100644
--- a/cryptozombie-lessons_ru/ru/1/lessonoverview.md
+++ b/cryptozombie-lessons_ru/ru/1/lessonoverview.md
@@ -10,7 +10,7 @@ material:
     answer: 1
 ---
 
-В Уроке 1 вы выстроили «Фабрику Зомби» с целью создать зомби-армию. 
+В Уроке 1 тобой была создана «Фабрика Зомби» с целью собрать зомби-армию. 
 
 * Фабрика будет содержать данные всех зомби в армии
 * У фабрики будет функция создания новых зомби
@@ -28,14 +28,14 @@ material:
 
 Как и в настоящей ДНК, различные части этого числа будут отражать специфические черты. Первые две цифры определяют внешний вид головы зомби, следующие две — разрез глаз и так далее. 
 
-> Обрати внимание: это сильно упрощенный урок, поэтому у зомби возможно только 7 разных типов голов (хотя из 2 цифр можно получить 100 возможных вариантов). Если мы захотим увеличить число вариантов зомби, . бы хотели увеличить количество вариаций зомби.для Note: For this tutorial, we've kept things simple, and our zombies can have only 7 different types of heads (even though 2 digits allow 100 possible options). Later on we could add more head types if we wanted to increase the number of zombie variations.
+> Обрати внимание: это сильно упрощенный урок, поэтому у зомби возможно только 7 разных типов голов (хотя из 2 цифр можно получить 100 возможных вариантов). Если мы захотим увеличить число вариантов зомби, то потом добавим больше типов голов. 
 
-Например, первые 2 цифры зомби-ДНК, приведенной выше, равны `83`. Чтобы определить тип головы зомби, мы выполняем операцию `83 % 7 + 1` = 7. Этот зомби получит седьмой тип головы.  For example, the first 2 digits of our example DNA above are `83`. To map that to the zombie's head type, we do `83 % 7 + 1` = 7. So this Zombie would have the 7th zombie head type. 
+Например, первые 2 цифры зомби-ДНК, приведенной выше, равны `83`. Чтобы определить тип головы зомби, мы выполняем операцию `83 % 7 + 1` = 7. Этот зомби получит седьмой тип головы.
 
-Чтобы увидеть, какой черте соответствует `83`, в правой панели сдвинь слайдер `head gene` (ген головы) до типа 7 (шапка Санта Клауса)до  In the panel to the right, go ahead and move the `head gene` slider to the 7th head (the Santa hat) to see what trait the `83` would correspond to.
+Чтобы увидеть, какой черте соответствует `83`, в правой панели сдвинь слайдер `head gene` (ген головы) до типа 7. Это шапка Санта Клауса!
 
 # Попробуй!
 
-1. Поиграй со слайдером в праой части страницы и увидишь, как различные цифровые комбинации соответсвуют разным аспектам внешнего вида зомби. Play with the sliders on the right side of the page. Experiment to see how the different numerical values correspond to different aspects of the zombie's appearance.
+1. Поиграй со слайдером в правой части страницы и увидишь, как различные цифровые комбинации соответствуют разным аспектам внешнего вида зомби. 
 
-Ладно, поигрались и хватит. Когда готов, нажми на кнопку «Следующая глава» внизу страницы, и погрузись в изучение Solidity целиком! Ok, enough playing around. When you're ready to continue, hit "Next Chapter" below, and let's dive into learning Solidity!
+Ладно, поигрались и хватит. Когда надоест, нажми на кнопку «Следующая глава» внизу страницы, и погрузись в изучение Solidity целиком! 
diff --git a/cryptozombie-lessons_ru/ru/1/math.md b/cryptozombie-lessons_ru/ru/1/math.md
index 3274578..64bcebb 100644
--- a/cryptozombie-lessons_ru/ru/1/math.md
+++ b/cryptozombie-lessons_ru/ru/1/math.md
@@ -10,7 +10,7 @@ material:
       contract ZombieFactory {
 
           uint dnaDigits = 16;
-          //начало здесь
+          // Начало здесь
 
       }
     answer: >
@@ -32,7 +32,7 @@ material:
 * Вычитание: `x - y`,
 * Умножение: `x * y`
 * Деление: `x / y`
-* Модуль и остаток от деления: `x % y` _(например, `13 % 5` будет равно `3`, так как если разделить 13 на 5, в остатке получится 3)_
+* Модуль и остаток от деления: `x % y` _(например, `13 % 5` будет равно `3`, если разделить 13 на 5, в остатке 3)_
 
 Solidity поддерживает экспоненциальные операции **_exponential operator_** — возведение в степень (например "x в степени y", x^y):
 
diff --git a/cryptozombie-lessons_ru/ru/1/structs.md b/cryptozombie-lessons_ru/ru/1/structs.md
index 6dbeb4d..73f0666 100644
--- a/cryptozombie-lessons_ru/ru/1/structs.md
+++ b/cryptozombie-lessons_ru/ru/1/structs.md
@@ -12,7 +12,7 @@ material:
           uint dnaDigits = 16;
           uint dnaModulus = 10 ** dnaDigits;
 
-          // начало здесь
+          // Начало здесь
 
       }
     answer: >
@@ -44,7 +44,7 @@ struct Person {
 
 С помощью структур ты создашь более сложные типы данных с несколькими свойствами.
 
-> Обрати внимание, что мы только что ввели новый тип `string` (строка). Строки используются для данных в кодировке UTF-8 произвольной длины. Пример строки приветствия = "Привет, мир!” `string greeting = "Hello world!"`
+> Обрати внимание, что мы только что ввели новый тип `string` (строка). Строки используются для данных в кодировке UTF-8 произвольной длины. Пример строки приветствия = «Привет, мир!»
 
 # Проверь себя
 
diff --git a/cryptozombie-lessons_ru/ru/1/web3js.md b/cryptozombie-lessons_ru/ru/1/web3js.md
index 9beb272..ca0fbc0 100644
--- a/cryptozombie-lessons_ru/ru/1/web3js.md
+++ b/cryptozombie-lessons_ru/ru/1/web3js.md
@@ -16,7 +16,7 @@ material:
 
 В следующем уроке мы подробно изучим, как развернуть контракт и настроить Web3.js. А сейчас просто посмотрим, как Web3.js будет взаимодействовать с развернутым контрактом. 
 
-Не беспокойтесь, если пока не все понятно. 
+Не беспокойся, если пока не все понятно. 
 
 ```
 // Как осуществляется доступ к контракту:
@@ -48,14 +48,14 @@ function generateZombie(id, name, dna) {
 
   let zombieDetails = {
     // Первые 2 цифры задают голову. Всего возможно 7 вариантов голов, поэтому % 7
-    // Получить числа от 0 до 6, затем добавить 1, чтобы сделать их от 1 до 7. Так будет 7 вариантов
+    // Получить цифры от 0 до 6, затем добавить 1, чтобы сделать их от 1 до 7. Так будет 7 вариантов
     // Файлы с именами от "head1.png" до "head7.png" загружаем, исходя из этого номера:
     headChoice: dnaStr.substring(0, 2) % 7 + 1,
     // Вторые 2 цифры задают глаза, 11 вариантов:
     eyeChoice: dnaStr.substring(2, 4) % 11 + 1,
     // 6 вариантов мундиров:
     shirtChoice: dnaStr.substring(4, 6) % 6 + 1,
-    // Последние 6 цифр задают цвет. Обновления используют фильтр CSS, угол поворота которого составляет 360 градусов:
+    // Последние 6 цифр задают цвет. Обновления используют фильтр CSS с углом поворота 360 градусов:
     skinColorChoice: parseInt(dnaStr.substring(6, 8) / 100 * 360),
     eyeColorChoice: parseInt(dnaStr.substring(8, 10) / 100 * 360),
     clothesColorChoice: parseInt(dnaStr.substring(10, 12) / 100 * 360),
@@ -66,10 +66,10 @@ function generateZombie(id, name, dna) {
 }
 ```
 
-В результате javascript берет значения, сгенерированные в `zombieDetails`, и применяет «браузерную магию» javascript (мы используем Vue.js), чтобы изменить изображения и примененить CSS-фильтр. В следующем уроке вы увидите код целиком. 
+В результате javascript берет значения, сгенерированные в `zombieDetails`, и применяет «браузерную магию» javascript (мы используем Vue.js), чтобы изменить изображения и примененить CSS-фильтр. В следующем уроке ты увидишь код целиком. 
 
-# Попробуйте!
+# Попробуй!
 
-Вперед! Напишите свое имя в правом поле и увидите, какой получится зомби! 
+Вперед! Напиши свое имя в правом поле и увидишь, какой получится зомби! 
 
-**Как только получите зомби, который вам нравится, нажмите на кнопку «Следующий раздел». Вы сохраните зомби и закончите урок 1!**
+**Как только получишь зомби, который тебе нравится, жми на кнопку «Следующий раздел». Ты сохранишь зомби и завершишь урок 1!**
diff --git a/cryptozombie-lessons_ru/ru/2/00-overview.md b/cryptozombie-lessons_ru/ru/2/00-overview.md
index 7acf808..a66184b 100644
--- a/cryptozombie-lessons_ru/ru/2/00-overview.md
+++ b/cryptozombie-lessons_ru/ru/2/00-overview.md
@@ -1,12 +1,11 @@
 ---
-title: Zombies Attack Their Victims
-header: So, you've made it to Lesson 2!
+title: Зомби идут в атаку!
+header: Поздравляем, перед тобой Урок 2!
 roadmap: roadmap2.jpg
 ---
 
-Impressive, human! You're a better coder than I thought.
+Потрясающе, человек! Ты пишешь код лучше, чем мы думали.
 
-Lesson 2 will teach you how to **multiply your zombie army by feeding on other lifeforms**.
+В Уроке 2 ты научишься, как **увеличить армию зомби, питаясь иными формами жизни**.
 
-In this lesson we will cover some more advanced Solidity concepts, so it's highly
-recommended that you complete Lesson 1 before starting.
+В этом разделе мы освоим более продвинутые концепции Solidity, поэтому рекомендуем полностью завершить Урок 1.
diff --git a/cryptozombie-lessons_ru/ru/2/1-overview.md b/cryptozombie-lessons_ru/ru/2/1-overview.md
index f878527..59e65e7 100644
--- a/cryptozombie-lessons_ru/ru/2/1-overview.md
+++ b/cryptozombie-lessons_ru/ru/2/1-overview.md
@@ -1,6 +1,6 @@
 ---
-title: Lesson 2 Overview
-actions: ['checkAnswer', 'hints']
+title: Обзор Урока 2
+actions: ['Проверить', 'Подсказать']
 material:
   saveZombie: false
   zombieBattle:
@@ -11,24 +11,25 @@ material:
     answer: 1
 ---
 
-In lesson 1, we created a function that takes a name, uses it to generate a random zombie, and adds that zombie to our app's zombie database on the blockchain.
+В первом уроке мы создали функцию, которая берет имя, из него генерирует случайного зомби, а потом добавляет его в базу данных блокчейн-приложения.
 
-In lesson 2, we're going to make our app more game-like: We're going to make it multi-player, and we'll also be adding a more fun way to create zombies instead of just generating them randomly.
+Во втором уроке мы займемся геймифицикацией приложение: добавим многопользовательский режим, а вместо простой случайной генерации сделаем создание зомби более разнообразным.
 
-How will we create new zombies? By having our zombies "feed" on other lifeforms!
+Как же теперь будут появляться новые зомби? Мы заставим старых зомби питаться другими формами жизни! 
 
-## Zombie Feeding
+## Питание зомби
 
-When a zombie feeds, it infects the host with a virus. The virus then turns the host into a new zombie that joins your army. The new zombie's DNA will be calculated from the previous zombie's DNA and the host's DNA.
+Когда зомби питается, он передает хозяину вирус. Затем вирус превращает съеденного в нового зомби, который присоединяется к твоей армии. ДНК нового зомби вычисляется из ДНК нападающего зомби и ДНК съеденного.
 
-And what do our zombies like to feed on most?
+Кем зомби любят питаться больше всего?
 
-To find that out... You'll have to complete lesson 2!
+Закончи Урок 2 и узнаешь! 
 
-# Put it to the test
+# Попробуй!
 
-There's a simple demo of feeding to the right. Click on a human to see what happens when your zombie feeds!
+Справа — простая демонстрация того, как питается зомби! Кликни на человека, и увидишь что будет, когда зобми его сожрет!
 
-You can see that the new zombie's DNA is determined by your original zombie's DNA, as well as the host's DNA.
+Видишь, ДНК зомби определяется собсвенной ДНК зомби и ДНК съеденного человека. 
+
+Когда захочешь двигаться дальше, кликай на «Следующая глава», и приступим к созданию многопользовательского режима.
 
-When you're ready, click "Next chapter" to move on, and let's get started by making our game multi-player.
diff --git a/cryptozombie-lessons_ru/ru/2/10-interactingcontracts.md b/cryptozombie-lessons_ru/ru/2/10-interactingcontracts.md
index 3b14701..e2ae7e1 100644
--- a/cryptozombie-lessons_ru/ru/2/10-interactingcontracts.md
+++ b/cryptozombie-lessons_ru/ru/2/10-interactingcontracts.md
@@ -1,6 +1,6 @@
 ---
-title: What Do Zombies Eat?
-actions: ['checkAnswer', 'hints']
+title: Кем питаются зомби?
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -10,7 +10,7 @@ material:
 
         import "./zombiefactory.sol";
 
-        // Create KittyInterface here
+        // Здесь создай интерфейс Криптокотика
 
         contract ZombieFeeding is ZombieFactory {
 
@@ -95,23 +95,23 @@ material:
       }
 ---
 
-It's time to feed our zombies! And what do zombies like to eat most?
+Время покормить зомби! Чем они питаются?
 
-Well it just so happens that CryptoZombies love to eat...
+Звезды сошлись так, что зомби питаются...
 
-**CryptoKitties!** 😱😱😱
+**Криптокотиками!** 😱😱😱
 
-(Yes, I'm serious 😆 )
+(Мы серьезно 😆)
 
-In order to do this we'll need to read the kittyDna from the CryptoKitties smart contract. We can do that because the CryptoKitties data is stored openly on the blockchain. Isn't the blockchain cool?!
+Для этого нам нужно будет считать kittyDna из смарт-контракта Криптокотиков. Это возможно, потому что данные котиков хранятся в открытом блокчейне. Клево, правда?
 
-Don't worry — our game isn't actually going to hurt anyone's CryptoKitty. We're only *reading* the CryptoKitties data, we're not able to actually delete it 😉
+Не волнуйся - на самом деле ни одного Криптокотика не пострадает. Мы только *считаем* данные Криптокотиков, но не сможем удалить их 😉
 
-## Interacting with other contracts
+## Взаимодействие с другими контрактами
 
-For our contract to talk to another contract on the blockchain that we don't own, first we need to define an **_interface_**.
+Чтобы наш контракт связался с другим контрактом в блокчейне, которым владеем не мы, сначала  нужно определить **_интерфейс_**.
 
-Let's look at a simple example. Say there was a contract on the blockchain that looked like this:
+Посмотрим простой пример. Допустим, в блокчейне существует такой контракт: 
 
 ```
 contract LuckyNumber {
@@ -127,11 +127,11 @@ contract LuckyNumber {
 }
 ```
 
-This would be a simple contract where anyone could store their lucky number, and it will be associated with their Ethereum address. Then anyone else could look up that person's lucky number using their address.
+Это простой контракт, где каждый может хранить свой счастливый номер, связанный с личным адресом Ethereum. Тогда любой может найти счастливый номер человека по адресу.
 
-Now let's say we had an external contract that wanted to read the data in this contract using the `getNum` function. 
+Теперь допустим, что у нас есть другой внешний контракт, который хочет считать данные в этом контракте, используя функцию `getNum`.
 
-First we'd have to define an **_interface_** of the `LuckyNumber` contract:
+Сначала нам надо будет определить **_интерфейс_** контракта `LuckyNumber` (счастливый номер):
 
 ```
 contract NumberInterface {
@@ -139,21 +139,21 @@ contract NumberInterface {
 }
 ```
 
-Notice that this looks like defining a contract, with a few differences. For one, we're only declaring the functions we want to interact with — in this case `getNum` — and we don't mention any of the other functions or state variables.
+Это похоже на определение контракта, но есть несколько отличий. Во-первых, мы объявляем только те функции, с которыми хотим взаимодействовать - в данном случае `getNum` - и не упоминаем другие функции или переменные состояния.
 
-Secondly, we're not defining the function bodies. Instead of curly braces (`{` and `}`), we're simply ending the function declaration with a semi-colon (`;`).
+Во-вторых, мы не определяем тела функций. Вместо фигурных скобок (`{` и `}`) мы заканчиваем задание функции точкой с запятой (`;`).
 
-So it kind of looks like a contract skeleton. This is how the compiler knows it's an interface.
+Это как скелет контракта. Так компилятор узнает, что это интерфейс.
 
-By including this interface in our dapp's code our contract knows what the other contract's functions look like, how to call them, and what sort of response to expect.
+Если включить интерфейс в код DApp, наш контракт узнает, как выглядят функции другого контракта, как их вызвать и какой придет ответ.
 
-We'll get into actually calling the other contract's functions in the next lesson, but for now let's declare our interface for the CryptoKitties contract.
+В следующем уроке мы будем вызывать функции другого контракта, а пока зададим интерфейс для контракта Криптокотиков.
 
-# Put it to the test
+# Проверь себя
 
-We've looked up the CryptoKitties source code for you, and found a function called `getKitty` that returns all the kitty's data, including its "genes" (which is what our zombie game needs to form a new zombie!).
+Мы исследовали для тебя исходный код Криптокотиков и нашли функцию «getKitty», которая возвращает все данные котика, включая «гены» (как раз то, что нам нужно, чтобы создать новых зомби!).
 
-The function looks like this:
+Функция выглядит так:
 
 ```
 function getKitty(uint256 _id) external view returns (
@@ -170,7 +170,7 @@ function getKitty(uint256 _id) external view returns (
 ) {
     Kitty storage kit = kitties[_id];
 
-    // if this variable is 0 then it's not gestating
+    // Если эта переменная равна нулю, то она не беременеет:)
     isGestating = (kit.siringWithId != 0);
     isReady = (kit.cooldownEndBlock <= block.number);
     cooldownIndex = uint256(kit.cooldownIndex);
@@ -184,10 +184,10 @@ function getKitty(uint256 _id) external view returns (
 }
 ```
 
-The function looks a bit different than we're used to. You can see it returns... a bunch of different values. If you're coming from a programming language like Javascript, this is different — in Solidity you can return more than one value from a function.
+Функция выглядит не совсем привычно. Смотри, она возвращает кучу разных значений! В отличие от Javascript в Solidity можно вернуть больше одного значения из функции.
 
-Now that we know what this function looks like, we can use it to create an interface:
+Теперь, когда мы знаем, как должна выглядеть функция, можем использовать ее для создания интерфейса:
 
-1. Define an interface called `KittyInterface`. Remember, this looks just like creating a new contract — we use the `contract` keyword.
+1. Задайте интерфейс под названием «KittyInterface». Это похоже на создание нового контракта - используем ключевое слово `contract`.
 
-2. Inside the interface, define the function `getKitty` (which should be a copy/paste of the function above, but with a semi-colon after the `returns` statement, instead of everything inside the curly braces.
+2. Внутри интерфейса задайте функцию `getKitty` (копировать/вставить функцию, приведенную выше,но после оператора `return` идет точка с запятой, а не все выражение внутри фигурных скобок.
diff --git a/cryptozombie-lessons_ru/ru/2/11-interactingcontracts2.md b/cryptozombie-lessons_ru/ru/2/11-interactingcontracts2.md
index d670698..ef28009 100644
--- a/cryptozombie-lessons_ru/ru/2/11-interactingcontracts2.md
+++ b/cryptozombie-lessons_ru/ru/2/11-interactingcontracts2.md
@@ -1,6 +1,6 @@
 ---
-title: Using an Interface
-actions: ['checkAnswer', 'hints']
+title: Используем интерфейс
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -28,7 +28,7 @@ material:
         contract ZombieFeeding is ZombieFactory {
 
           address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
-          // Initialize kittyContract here using `ckAddress` from above
+          // Здесь запусти контракт котика, взяв сверху `ckAddress` 
 
           function feedAndMultiply(uint _zombieId, uint _targetDna) public {
             require(msg.sender == zombieToOwner[_zombieId]);
@@ -114,7 +114,7 @@ material:
       }
 ---
 
-Continuing our previous example with `NumberInterface`, once we've defined the interface as:
+Продолжим наш предыдущий пример с `NumberInterface`, как только зададим интерфейс:
 
 ```
 contract NumberInterface {
@@ -122,27 +122,26 @@ contract NumberInterface {
 }
 ```
 
-We can use it in a contract as follows:
-
+Мы можем использовать его в контракте следующим образом:
 ```
 contract MyContract {
   address NumberInterfaceAddress = 0xab38... 
-  // ^ The address of the FavoriteNumber contract on Ethereum
+  // ^ Адрес контракта FavoriteNumber в Ethereum
   NumberInterface numberContract = NumberInterface(NumberInterfaceAddress)
-  // Now `numberContract` is pointing to the other contract
+  // Сейчас `numberContract` указывает на другие контракты
 
   function someFunction() public {
-    // Now we can call `getNum` from that contract:
+    // Теперь можно вызвать `getNum` из контракта:
     uint num = numberContract.getNum(msg.sender);
-    // ...and do something with `num` here
+    // ...и сделать что-то с `num` здесь
   }
 }
 ```
 
-In this way, your contract can interact with any other contract on the Ethereum blockchain, as long they expose those functions as `public` or `external`.
+Этим способом контракт будет взаимодействовать с всеми другими контрактами в блокчейне Ethereum, если они задают функции как `public` (открытые) или `external` (внешние). 
 
-# Put it to the test
+# Проверь себя
 
-Let's set up our contract to read from the CryptoKitties smart contract!
+Установим наш контракт на чтение из смарт-контракта Криптокотиков!
 
-1. I've saved the address of the CryptoKitties contract in the code for you, under a variable named `ckAddress`. In the next line, create a `KittyInterface` named `kittyContract`, and initialize it with `ckAddress` — just like we did with `numberContract` above.
+1. Мы нашли для тебя адрес контракта Криптокотиков и сохранили его внутри кода под переменным именем `ckAddress`. В следующей строчке создай `KittyInterface` (интерфейс котика) и запусти его с помощью `ckAddress` — так же, как мы делали с `numberContract` вверху.
diff --git a/cryptozombie-lessons_ru/ru/2/12-multiplereturns.md b/cryptozombie-lessons_ru/ru/2/12-multiplereturns.md
index 44d005e..2a1b189 100644
--- a/cryptozombie-lessons_ru/ru/2/12-multiplereturns.md
+++ b/cryptozombie-lessons_ru/ru/2/12-multiplereturns.md
@@ -1,6 +1,6 @@
 ---
-title: Handling Multiple Return Values
-actions: ['checkAnswer', 'hints']
+title: Работа с несколькими возвращаемыми значениями
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -38,7 +38,7 @@ material:
             _createZombie("NoName", newDna);
           }
 
-          // define function here
+          // Здесь задай функцию
 
         }
       "zombiefactory.sol": |
@@ -122,7 +122,7 @@ material:
       }
 ---
 
-This `getKitty` function is the first example we've seen that returns multiple values. Let's look at how to handle them:
+Функция `getKitty` — первый видимый нами пример возвращения множественных значиний. Посмотрим, как с ними обращаться:
 
 ```
 function multipleReturns() internal returns(uint a, uint b, uint c) {
@@ -133,30 +133,30 @@ function processMultipleReturns() external {
   uint a;
   uint b;
   uint c;
-  // This is how you do multiple assignment:
+  // Вот как выполнять несколько заданий:
   (a, b, c) = multipleReturns();
 }
 
-// Or if we only cared about one of the values:
+// А если нам важно только одно значение...
 function getLastReturnValue() external {
   uint c;
-  // We can just leave the other fields blank:
+  // ...мы просто оставим другое поле пустым
   (,,c) = multipleReturns();
 }
 ```
 
-# Put it to the test
+# Проверь себя
 
-Time to interact with the CryptoKitties contract!
+Пробил час начала взаимодействия с контрактом Криптокотиков! 
 
-Let's make a function that gets the kitty genes from the contract:
+Создадим функцию, которая получает гены котика из контракта:
 
-1. Make a function called `feedOnKitty`. It will take 2 `uint` parameters, `_zombieId` and `_kittyId`, and should be a `public` function.
+1. Создай функцию, которая называется `feedOnKitty`. Она будет брать 2 параметра `uint` — `_zombieId` и `_kittyId`, и она должна быть `public` — открытой функцией.
 
-2. The function should first declare a `uint` named `kittyDna`.
+2. Сначала функция задает `uint` под названием `kittyDna`.
 
-  > Note: In our `KittyInterface`, `genes` is a `uint256` — but if you remember back to lesson 1, `uint` is an alias for `uint256` — they're the same thing.
+  > Обрати внимание: В нашем `KittyInterface` (интерфесе криптокотика), `genes` — это `uint256`, но если ты помнишь Урок 1, `uint` — синоним для `uint256`, это одно и то же.
 
-3. The function should then call the `kittyContract.getKitty` function with `_kittyId` and store `genes` in `kittyDna`. Remember — `getKitty` returns a ton of variables. (10 to be exact — I'm nice, I counted them for you!). But all we care about is the last one, `genes`. Count your commas carefully!
+3. Затем наша функция потом должна вызывать функцию `kittyContract.getKitty` с помощью `_kittyId` и сохранять `genes` в `kittyDna`. Запомни — `getKitty` возвращает тебе целый ворох переменных. (10 если быть точным — мы посчитали за тебя, не благодари). Но единственный важный нам — это последний, `genes`. Считай запятые внимательно!
 
-4. Finally, the function should call `feedAndMultiply`, and pass it both `_zombieId` and `kittyDna`.
+4. В конце функция должна вызывать `feedAndMultiply` (питаться и размножаться), и сообщать ей `_zombieId` и `kittyDna`.
diff --git a/cryptozombie-lessons_ru/ru/2/13-kittygenes.md b/cryptozombie-lessons_ru/ru/2/13-kittygenes.md
index 9302a2b..3910fae 100644
--- a/cryptozombie-lessons_ru/ru/2/13-kittygenes.md
+++ b/cryptozombie-lessons_ru/ru/2/13-kittygenes.md
@@ -1,6 +1,6 @@
 ---
-title: "Bonus: Kitty Genes"
-actions: ['checkAnswer', 'hints']
+title: Бонус: гены котика
+actions: [['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -30,20 +30,20 @@ material:
           address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
           KittyInterface kittyContract = KittyInterface(ckAddress);
 
-          // Modify function definition here:
+          // Здесь измени значение функции:
           function feedAndMultiply(uint _zombieId, uint _targetDna) public {
             require(msg.sender == zombieToOwner[_zombieId]);
             Zombie storage myZombie = zombies[_zombieId];
             _targetDna = _targetDna % dnaModulus;
             uint newDna = (myZombie.dna + _targetDna) / 2;
-            // Add an if statement here
+            // А здесь добавь оператор «или»: 
             _createZombie("NoName", newDna);
           }
 
           function feedOnKitty(uint _zombieId, uint _kittyId) public {
             uint kittyDna;
             (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
-            // And modify function call here:
+            // Здесь измени вызов функции:
             feedAndMultiply(_zombieId, kittyDna);
           }
 
@@ -133,40 +133,40 @@ material:
       }
 ---
 
-Our function logic is now complete... but let's add in one bonus feature.
+Мы закончили с логикой функции... но давай добавим небольшую бонусную фишку. 
 
-Let's make it so zombies made from kitties have some unique feature that shows they're cat-zombies.
+Сделаем так, чтобы зомби, полученные из котиков, обладали уникальной характеристику, показывающей, что они именно зомбокотики.
 
-To do this, we can add some special kitty code in the zombie's DNA.
+Для этого добавим специальный котиковый код в ДНК зомби. 
 
-If you recall from lesson 1, we're currently only using the first 12 digits of our 16 digit DNA to determine the zombie's appearance. So let's use the last 2 unused digits to handle "special" characteristics. 
+Если помнишь, в первом уроке мы использовали только первые 12 цифр из 16-циферного ДНК, чтобы определить внешний вид зомби. Поэтому давай возьмем последние 2 цифры из неиспользованных, чтобы разобраться со «специальными» характеристиками. 
 
-We'll say that cat-zombies have `99` as their last two digits of DNA (since cats have 9 lives). So in our code, we'll say `if` a zombie comes from a cat, then set the last two digits of DNA to `99`.
+Допустим, последние две цифры ДНК зомбокотика `99` (ведь известно, что у кошки 9 жизней). В нашем коде, `if` (если) зомби происходит от котика, то последние две цифры в ДНК мы установим как `99`.
 
-## If statements
+## Оператор «или»
 
-If statements in Solidity look just like javascript:
+Оператор «или» в Solidity похож на javascript:
 
 ```
 function eatBLT(string sandwich) public {
-  // Remember with strings, we have to compare their keccak256 hashes
-  // to check equality
+  // Не забудь, что в строках надо сравнивать keccak256-хэши,
+  // чтобы проверить, равны они или нет.
   if (keccak256(sandwich) == keccak256("BLT")) {
     eat();
   }
 }
 ```
 
-# Put it to the test
+# Проверь себя
 
-Let's implement cat genes in our zombie code.
+Введем ген котика в наш зомби-код
 
-1. First, let's change the function definition for `feedAndMultiply` so it takes a 3rd argument: a `string` named `_species`
+1. Сначала давай изменим определение функции на `feedAndMultiply` (питаться и размножаться), чтобы она брала третий аргумент: `string` (строку) под названием `_species` (виды).
 
-2. Next, after we calculate the new zombie's DNA, let's add an `if` statement comparing the `keccak256` hashes of `_species` and the string `"kitty"`
+2. Когда мы вычислили ДНК нового зомби, добавим оператор `if` (или), чтобы он сравнил `keccak256` хэши строк `_species` (виды) и `"kitty"` (котик).
 
-3. Inside the `if` statement, we want to replace the last 2 digits of DNA with `99`. One way to do this is using the logic: `newDna = newDna - newDna % 100 + 99;`.
+3. Внутри оператора `if` (или) мы хотим заменить последние 2 цифры ДНК на `99`. Один из способов сделать это — использовать логику `newDna = newDna - newDna % 100 + 99;`.
 
-  > Explanation: Assume `newDna` is `334455`. Then `newDna % 100` is `55`, so `newDna - newDna % 100` is `334400`. Finally add `99` to get `334499`.
+  > Объяснение: предположим, `newDna` равна `334455`. Тогда `newDna % 100` равна `55`, поэтому `newDna - newDna % 100` это `334400`. В конце добавим `99` чтобы получить `334499`.
 
-4. Lastly, we need to change the function call inside `feedOnKitty`. When it calls `feedAndMultiply`, add the parameter `"kitty"` to the end.
+4. И последнее, нам надо заменить функцию внутри `feedOnKitty`. Когда она вызывает `feedAndMultiply`, добавь в конец параметр `"kitty"`.
diff --git a/cryptozombie-lessons_ru/ru/2/14-wrappingitup.md b/cryptozombie-lessons_ru/ru/2/14-wrappingitup.md
index b11cb9b..f7197be 100644
--- a/cryptozombie-lessons_ru/ru/2/14-wrappingitup.md
+++ b/cryptozombie-lessons_ru/ru/2/14-wrappingitup.md
@@ -1,6 +1,6 @@
 ---
-title: Wrapping It Up
-actions: ['checkAnswer', 'hints']
+title: Подведем итог
+actions: ['Проверить', 'Подсказать']
 material:
   saveZombie: true
   zombieBattle:
@@ -11,15 +11,15 @@ material:
     answer: 1
 ---
 
-That's it, you've completed lesson 2!
+Вот и все, Урок 2 завершен!
 
-You can check out the demo to the right to see it in action. Go ahead, I know you can't wait until the bottom of this page 😉. Click a kitty to attack, and see the new kitty zombie you get!
+Чтобы увидеть все в действии, посмотри демо в поле справа. Вперед! Уверены, что ты умираешь от любопытства. Кликни, чтобы напасть на котика, и оцени своего нового зомбокитти! 
 
-## Javascript implementation
+## Внедрение Javascript 
 
-Once we're ready to deploy this contract to Ethereum we'll just compile and deploy `ZombieFeeding` — since this contract is our final contract that inherits from `ZombieFactory`, and has access to all the public methods in both contracts.
+Как только мы готовы деплоить контракт в Ethereum, то просто компилируем и разворачиваем `ZombieFeeding` — это наш окончательный контракт, который наследуется от `ZombieFactory` и имеет доступ ко всем открытым методам обоих контрактов.
 
-Let's look at an example of interacting with our deployed contract using Javascript and web3.js:
+Посмотри пример взаимодействия развернутого контракта с использование Javascript и web3.js:
 
 ```
 var abi = /* abi generated by the compiler */
@@ -27,39 +27,40 @@ var ZombieFeedingContract = web3.eth.contract(abi)
 var contractAddress = /* our contract address on Ethereum after deploying */
 var ZombieFeeding = ZombieFeedingContract.at(contractAddress)
 
-// Assuming we have our zombie's ID and the kitty ID we want to attack
+// Предположим, что у нас есть ID зомби и ID котика, на которого мы нападаем 
 let zombieId = 1;
 let kittyId = 1;
 
-// To get the CryptoKitty's image, we need to query their web API. This
-// information isn't stored on the blockchain, just their webserver.
-// If everything was stored on a blockchain, we wouldn't have to worry
-// about the server going down, them changing their API, or the company 
-// blocking us from loading their assets if they don't like our zombie game ;)
+// Чтобы получить изображение Криптокотика, надо запросить его веб-API. 
+// Эта информация хранится не в блокчейне, а на сервере. 
+// Если бы все хранилось в блокчейне, то не нужно было бы беспокоиться,
+// что упадет сервер, сменят API, или компания отрубит доступ к их коду,
+// потому что им не понравится наши зомбаки.;)
 let apiUrl = "https://api.cryptokitties.co/kitties/" + kittyId
 $.get(apiUrl, function(data) {
   let imgUrl = data.image_url
-  // do something to display the image
+  // Выведи изображение 
 })
 
-// When the user clicks on a kitty:
+// когда игрок кликает на котика:
 $(".kittyImage").click(function(e) {
-  // Call our contract's `feedOnKitty` method
+  // Вызываем метод `feedOnKitty` из нашего контракта
   ZombieFeeding.feedOnKitty(zombieId, kittyId)
 })
 
-// Listen for a NewZombie event from our contract so we can display it:
+// Слушаем событие NewZombie из нашего контракта и отображаем его: 
+
 ZombieFactory.NewZombie(function(error, result) {
   if (error) return
-  // This function will display the zombie, like in lesson 1:
+  // Функция отобразит зомби, как в Уроке 1:
   generateZombie(result.zombieId, result.name, result.dna)
 })
 ```
 
-# Give it a try!
+# Попробуй!
 
-Select the kitty you want to feed on. Your zombie's DNA and the kitty's DNA will combine, and you'll get a new zombie in your army!
+Выбери котика, которого хочешь сожрать. ДНК твоего зомби и ДНК котика смешаются, и вот у тебя готов новый солдат для зомби-армии!
 
-Notice those cute cat legs on your new zombie? That's our final `99` digits of DNA at work 😉
+Видишь эти клевые кошачьи лапки у своего нового котозомби? Вот так проявляются последние котоцифры `99` в ДНК 😉 
 
-You can start over and try again if you want. When you get a kitty zombie you're happy with (you only get to keep one), go ahead and proceed to the next chapter to complete lesson 2!
+Если понравилось, попробуй еще! Когда сделаешь зомбокотика, который тебе понравится, переходи к Уроку 3! 
diff --git a/cryptozombie-lessons_ru/ru/2/15-lessoncomplete.md b/cryptozombie-lessons_ru/ru/2/15-lessoncomplete.md
index 6954aa4..e1fd3b4 100644
--- a/cryptozombie-lessons_ru/ru/2/15-lessoncomplete.md
+++ b/cryptozombie-lessons_ru/ru/2/15-lessoncomplete.md
@@ -1,6 +1,6 @@
 ---
-title: Lesson 2 Complete!
-actions: ['checkAnswer', 'hints']
+title: Урок 2 завершен!
+actions: ['Проверить', 'Подсказать']
 material:
   lessonComplete:
     answer: 1
diff --git a/cryptozombie-lessons_ru/ru/2/2-mappings.md b/cryptozombie-lessons_ru/ru/2/2-mappings.md
index 628aa13..80245d1 100644
--- a/cryptozombie-lessons_ru/ru/2/2-mappings.md
+++ b/cryptozombie-lessons_ru/ru/2/2-mappings.md
@@ -1,6 +1,6 @@
 ---
-title: Mappings and Addresses
-actions: ['checkAnswer', 'hints']
+title: Адреса и соответсвия
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -21,7 +21,7 @@ material:
 
           Zombie[] public zombies;
 
-          // declare mappings here
+          // Здесь задай отображение
 
           function _createZombie(string _name, uint _dna) private {
               uint id = zombies.push(Zombie(_name, _dna)) - 1;
@@ -78,43 +78,43 @@ material:
       }
 ---
 
-Let's make our game multi-player by giving the zombies in our database an owner.
+Давай сделаем нашу игру многопользовательской, дав владельца каждому зомби в базе данных.
 
-To do this, we'll need 2 new data types: `mapping` and `address`.
+Чтобы это осуществить, нам понадобятся 2 новых типа данных: `address` (адреса) и `mapping` (отображения).
 
-## Addresses
+## Адреса
 
-The Ethereum blockchain is made up of **_accounts_**, which you can think of like bank accounts. An account has a balance of **_Ether_** (the currency used on the Ethereum blockchain), and you can send and receive Ether payments to other accounts, just like your bank account can wire transfer money to other bank accounts.
+Блокчейн Ethereum состоит из **_аккаунтов_** (счетов), вроде банковских. На аккаунте находится баланс **_Эфира_** (криптовалюты блокчейна Ethereum). Ты можешь отправлять и получать платежи в Эфире на другие счета, также как ты переводишь деньги со своего банковского счета на счета других людей.
 
-Each account has an `address`, which you can think of like a bank account number. It's a unique identifier that points to that account, and it looks like this:
+У каждого счета есть `address` (адрес), наподобие номера банковского счета. Это уникальный идентификатор счета, который выглядит так: 
 
 `0x0cE446255506E92DF41614C46F1d6df9Cc969183`
 
-(This address belongs to the CryptoZombies team. If you're enjoying CryptoZombies, you can send us some Ether! 😉 )
+(Этот адрес принадлежит команде Криптозомби. Если тебе нравится игра, можешь послать нам эфир!😉). 
 
-We'll get into the nitty gritty of addresses in a later lesson, but for now you only need to understand that **an address is owned by a specific user** (or a smart contract).
+Мы изучим самое важное блокчейн-адресов в следующем уроке, сейчас же достаточно знать, что **адрес принадлежит определенному человеку** (или контракту). 
 
-So we can use it as a unique ID for ownership of our zombies. When a user creates new zombies by interacting with our app, we'll set ownership of those zombies to the Ethereum address that called the function.
+Поэтому мы можем использовать его как уникальный идентификатор принадлежности зомби. Когда пользователь создает нового зомби, взаимодействуя с нашим приложением, мы привязываем право собственности на зомби к адресу Ethereum, который вызвал функцию. 
 
-## Mappings
+## Соответсвия
 
-In Lesson 1 we looked at **_structs_** and **_arrays_**. **_Mappings_** are another way of storing organized data in Solidity.
+В первом уроке мы рассмотрели **_структуры_** и **_массивы_**. **_Соответствия_** — это еще один способ хранения упорядоченных данных в Solidity.
 
-Defining a `mapping` looks like this:
+Определение `mapping` (соответствий) выглядит как-то так:
 
 ```
-// For a financial app, storing a uint that holds the user's account balance:
+// Для финансового приложения мы храним uint, который содержит остаток на счете пользователя: 
 mapping (address => uint) public accountBalance;
-// Or could be used to store / lookup usernames based on userId
+// Или может использоваться для хранения / поиска имен пользователей на основе userId 
 mapping (uint => string) userIdToName;
 ```
 
-A mapping is essentially a key-value store for storing and looking up data. In the first example, the key is an `address` and the value is a `uint`, and in the second example the key is a `uint` and the value a `string`.
+Соответствия - это, по сути, распределенное хранилище типа «ключ — значение», в котором можно хранить и искать данные. В первом примере ключ — это «адрес», а значение - «uint», а во втором примере ключ - «uint», а значение — «строка». 
 
-# Put it to the test
+# Проверь себя
 
-To store zombie ownership, we're going to use two mappings: one that keeps track of the address that owns a zombie, and another that keeps track of how many zombies an owner has.
+Чтобы хранить информацию о правах собственности на зомби, используем два соответсвия: одно отслеживает адрес, которому принадлежит зомби, второе отслеживает, сколькими зомби владеет пользователь.
 
-1. Create a mapping called `zombieToOwner`. The key will be a `uint` (we'll store and look up the zombie based on its id) and the value an `address`. Let's make this mapping `public`.
+1. Создай `mapping` (соответствие) под названием `zombieToOwner`. Ключ — `uint` (мы будем хранить и искать зомби по id). Значение - `address`. Cделаем это сооветствие открытым (public).
 
-2. Create a mapping called `ownerZombieCount`, where the key is an `address` and the value a `uint`.
+2. Создай `mapping` (соответствие) под названием `ownerZombieCount`, где ключ — `address`, а значение — `uint`.
diff --git a/cryptozombie-lessons_ru/ru/2/3-msgsender.md b/cryptozombie-lessons_ru/ru/2/3-msgsender.md
index 4268d97..ceb96f0 100644
--- a/cryptozombie-lessons_ru/ru/2/3-msgsender.md
+++ b/cryptozombie-lessons_ru/ru/2/3-msgsender.md
@@ -1,6 +1,6 @@
 ---
-title: Msg.sender
-actions: ['checkAnswer', 'hints']
+title: Отправитель
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -26,7 +26,7 @@ material:
 
           function _createZombie(string _name, uint _dna) private {
               uint id = zombies.push(Zombie(_name, _dna)) - 1;
-              // start here
+              // Начало здесь
               NewZombie(id, _name, _dna);
           }
 
@@ -82,52 +82,52 @@ material:
       }
 ---
 
-Now that we have our mappings to keep track of who owns a zombie, we'll want to update the `_createZombie` method to use them.
+Теперь, когда у нас есть карта соответсвий для отслеживания владельцев зомби, надо обновить метод `_createZombie`.
 
-In order to do this, we need to use something called `msg.sender`.
+Для этого нам понадобится `msg.sender` (отправитель).
 
-## msg.sender
+## Отправитель
 
-In Solidity, there are certain global variables that are available to all functions. One of these is `msg.sender`, which refers to the `address` of the person (or smart contract) who called the current function.
+В Solidity существуют определенные глобальные переменные, доступные всем функциям. Одной из них является `msg.sender` (отправитель), который ссылается на `address` (адрес) человека или смарт-контракта, вызвавшего текущую функцию.
 
-> Note: In Solidity, function execution always needs to start with an external caller. A contract will just sit on the blockchain doing nothing until someone calls one of its functions. So there will always be a `msg.sender`.
+> Обрати внимание: В Solidity выполнение функции всегда начинается с внешнего вызова. Контракт в блокчейне ничего не делает, пока кто-то не вызовет одну из его функций. Поэтому всегда будет нужен `msg.sender`.
 
-Here's an example of using `msg.sender` and updating a `mapping`:
+Пример использования `msg.sender` для обновления `mapping`:
 
 ```
 mapping (address => uint) favoriteNumber;
 
 function setMyNumber(uint _myNumber) public {
-  // Update our `favoriteNumber` mapping to store `_myNumber` under `msg.sender`
+  // Обнови соответсвие `favoriteNumber`, чтобы сохранить `_myNumber` под `msg.sender`
   favoriteNumber[msg.sender] = _myNumber;
-  // ^ The syntax for storing data in a mapping is just like with arrays
+  // ^ Синтаксис для сохранения в карте соответствия такой же, как для массива
 }
 
 function whatIsMyNumber() public view returns (uint) {
-  // Retrieve the value stored in the sender's address
-  // Will be `0` if the sender hasn't called `setMyNumber` yet
+  // Затребуй значение, сохраненное в адресе отправителя 
+  // Оно будет равно `0`, если отправитель еще не вызывал `setMyNumber`
   return favoriteNumber[msg.sender];
 }
 ```
 
-In this trivial example, anyone could call `setMyNumber` and store a `uint` in our contract, which would be tied to their address. Then when they called `whatIsMyNumber`, they would be returned the `uint` that they stored.
+В этом элементарном примере любой может вызвать `setMyNumber` и сохранить `uint` в нашем контракте, который будет привязан к их адресу. Затем, когда они вызывают `whatIsMyNumber`, им вернется сохраненный `uint`.
 
-Using `msg.sender` gives you the security of the Ethereum blockchain — the only way someone can modify someone else's data would be to steal the private key associated with their Ethereum address.
+Использование `msg.sender` обеспечивает безопасность блокчейна Ethereum. Единственный способ изменить чужие данные - украсть приватный ключ адреса Ethereum.
 
-# Put it to the test
+# Проверь себя
 
-Let's update our `_createZombie` method from lesson 1 to assign ownership of the zombie to whoever called the function.
+Обновим метод `_createZombie` из Урока 1, чтобы дать право собственности зомби тому, кто вызвал функцию. 
 
-1. First, after we get back the new zombie's `id`, let's update our `zombieToOwner` mapping to store `msg.sender` under that `id`.
+1. Во-первых, когда мы получим `id` нового зомби, обновим нашу карту соответсвий  `zombieToOwner`, чтобы сохранить `msg.sender` под этим `id`.
 
-2. Second, let's increase `ownerZombieCount` for this `msg.sender`. 
+2. Во-вторых, увеличим `ownerZombieCount` для этого `msg.sender`. 
 
-In Solidity, you can increase a `uint` with `++`, just like in javascript:
+В Solidity можно увеличить `uint` с помощью `++`, как в javascript:
 
 ```
 uint number = 0;
 number++;
-// `number` is now `1`
+// `number` теперь равен `1`
 ```
 
-Your final answer for this chapter should be 2 lines of code.
+Готовый ответ должен содержать две строчки кода. 
diff --git a/cryptozombie-lessons_ru/ru/2/4-require.md b/cryptozombie-lessons_ru/ru/2/4-require.md
index bd2e3d4..138799d 100644
--- a/cryptozombie-lessons_ru/ru/2/4-require.md
+++ b/cryptozombie-lessons_ru/ru/2/4-require.md
@@ -1,6 +1,6 @@
 ---
-title: Require
-actions: ['checkAnswer', 'hints']
+title: Требования
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -37,7 +37,7 @@ material:
           }
 
           function createRandomZombie(string _name) public {
-              // start here
+              // Начало здесь
               uint randDna = _generateRandomDna(_name);
               _createZombie(_name, randDna);
           }
@@ -85,35 +85,35 @@ material:
       }
 ---
 
-In lesson 1, we made it so users can create new zombies by calling `createRandomZombie` and entering a name. However, if users could keep calling this function to create unlimited zombies in their army, the game wouldn't be very fun.
+В Уроке 1 мы дали пользователям возможность создания новых зомби, вызывая функцию `createRandomZombie` и вводя имя. Но если пользователи смогут неограниченно вызывать функцию и наплодят неограниченное число зомби в армии, будет совсем не круто.
 
-Let's make it so each player can only call this function once. That way new players will call it when they first start the game in order to create the initial zombie in their army.
+Сделаем так, чтобы каждый игрок мог вызвать эту функцию только один раз. Таким образом новые игроки вызовут функцию в начале игры и создать первого зомби в армии.
 
-How can we make it so this function can only be called once per player? 
+Как сделать, чтобы эта функция могла быть вызвана пользователем только один раз?
 
-For that we use `require`. `require` makes it so that the function will throw an error and stop executing if some condition is not true:
+Используем `require` (требование). `require` делает так, что функция выдает ошибку и прекращает выполнение. если одно из условий не верно: 
 
 ```
 function sayHiToVitalik(string _name) public returns (string) {
-  // Compares if _name equals "Vitalik". Throws an error and exits if not true.
-  // (Side note: Solidity doesn't have native string comparison, so we
-  // compare their keccak256 hashes to see if the strings are equal)
+  // Сравнивает, если _имя равно "Vitalik". Выдает ошибку и закрывается, если не верно.
+  // (Примечание: в Solidity нет родного сравнивателя строк, поэтому
+  // мы сравниваем их keccak256-хэши, чтобы увидеть, равны они или нет
   require(keccak256(_name) == keccak256("Vitalik"));
-  // If it's true, proceed with the function:
-  return "Hi!";
+  // Если верно, то переходим к выполнению функции:
+  return "Привет!";
 }
 ```
 
-If you call this function with `sayHiToVitalik("Vitalik")`, it will return "Hi!". If you call it with any other input, it will throw an error and not execute.
+Если ты вызовешь эту функцию с `sayHiToVitalik("Vitalik"), она вернет "Привет!". Если вызвать ее с любым другим вводом, она выдаст ошибку и не выполнится. 
 
-Thus `require` is quite useful for verifying certain conditions that must be true before running a function.
+Таким образом, `require` полезна для проверки верности определенных условий перед запуском функции. 
 
-# Put it to the test
+# Проверь себя
 
-In our zombie game, we don't want the user to be able to create unlimited zombies in their army by repeatedly calling `createRandomZombie` — it would make the game not very fun.
+В нашей зомби-игре мы не хотим, чтобы пользователь создавал неограниченное количество зомби в  армии, постоянно вызывая `createRandomZombie` - это не смешно.
 
-Let's use `require` to make sure this function only gets executed one time per user, when they create their first zombie.
+Используем `require`, чтобы убедиться, что функция выполняется только один раз, когда пользователь создает своего первого зомби.
 
-1. Put a `require` statement at the beginning of `createRandomZombie`. The function should check to make sure `ownerZombieCount[msg.sender]` is equal to `0`, and throw an error otherwise.
+1. Поставь оператор `require` в начале `createRandomZombie`. Функция должна проверить и убедиться, что `ownerZombieCount [msg.sender]` равно `0`, либо выдать ошибку.
 
-> Note: In Solidity, it doesn't matter which term you put first — both orders are equivalent. However, since our answer checker is really basic, it will only accept one answer as correct — it's expecting `ownerZombieCount[msg.sender]` to come first.
+> Обрати внимание. В Solidity не имеет значения, какой термин идет первым - ордеры эквивалентны. Но поскольку наш проверяльщик ответов очень примитивный, он будет принимать только один ответ как правильный - предполагается, что `ownerZombieCount [msg.sender]` будет стоять на первом месте.
diff --git a/cryptozombie-lessons_ru/ru/2/5-inheritance.md b/cryptozombie-lessons_ru/ru/2/5-inheritance.md
index d7813dc..459c082 100644
--- a/cryptozombie-lessons_ru/ru/2/5-inheritance.md
+++ b/cryptozombie-lessons_ru/ru/2/5-inheritance.md
@@ -1,6 +1,6 @@
 ---
-title: Inheritance
-actions: ['checkAnswer', 'hints']
+title: Наследование
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -44,7 +44,7 @@ material:
 
       }
 
-      // Start here
+      // Начало здесь
 
     answer: >
       pragma solidity ^0.4.19;
@@ -93,30 +93,30 @@ material:
 
 ---
 
-Our game code is getting quite long. Rather than making one extremely long contract, sometimes it makes sense to split your code logic across multiple contracts to organize the code.
+Код уже довольно длинный! Чтобы не делать один длиннющий контракт и организовать код, можно разбить логику кода на несколько контрактов. 
 
-One feature of Solidity that makes this more manageable is contract **_inheritance_**:
+В Solidity есть фича, которая помогает управлять длинными контрактами — **_наследование_**:
 
 ```
 contract Doge {
   function catchphrase() public returns (string) {
-    return "So Wow CryptoDoge";
+    return "Клевый песик";
   }
 }
 
 contract BabyDoge is Doge {
   function anotherCatchphrase() public returns (string) {
-    return "Such Moon BabyDoge";
+    return "Клевый щеночек";
   }
 }
 ```
 
-`BabyDoge` **_inherits_** from `Doge`. That means if you compile and deploy `BabyDoge`, it will have access to both `catchphrase()` and `anotherCatchphrase()` (and any other public functions we may define on `Doge`).
+`BabyDoge` (щенок) **_наследует_** `Doge` (Псу!). Если ты скомпилируешь и развернешь `BabyDoge`, он получит доступ и к `catchphrase()` и к `anotherCatchphrase()` (и ко всем остальным открытым функциям, которые мы опишем в `Doge`).
 
-This can be used for logical inheritance (such as with a subclass, a `Cat` is an `Animal`). But it can also be used simply for organizing your code by grouping similar logic together into different classes.
+Это можно использовать для логического наследования (как с подтипами, `Cat` (кошка) это `Animal` (животное)), или для простой организации кода, группируя вместе одинаковую логику  внутри различных классов. 
 
-# Put it to the test
+# Проверь себя
 
-In the next chapters, we're going to be implementing the functionality for our zombies to feed and multiply. Let's put this logic into its own class that inherits all the methods from `ZombieFactory`.
+В следующих главах мы собираемся наделить зомби способностью питаться и размножаться. Поместим эту логику в класс, который наследует все методы из `ZombieFactory`. 
 
-1. Make a contract called `ZombieFeeding` below `ZombieFactory`. This contract should inherit from our `ZombieFactory` contract.
+1. Создай контракт под названием `ZombieFeeding` сразу под `ZombieFactory`. Этот контракт наследует контракту из нашей Фабрики Зомби `ZombieFactory`. 
diff --git a/cryptozombie-lessons_ru/ru/2/6-importfiles.md b/cryptozombie-lessons_ru/ru/2/6-importfiles.md
index 1f2079b..f35b716 100644
--- a/cryptozombie-lessons_ru/ru/2/6-importfiles.md
+++ b/cryptozombie-lessons_ru/ru/2/6-importfiles.md
@@ -1,6 +1,6 @@
 ---
-title: Import
-actions: ['checkAnswer', 'hints']
+title: Импорт
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -8,7 +8,7 @@ material:
       "zombiefeeding.sol": |
         pragma solidity ^0.4.19;
 
-        // put import statement here
+        // Здесь помести оператор импорта
 
         contract ZombieFeeding is ZombieFactory {
 
@@ -63,11 +63,11 @@ material:
 
 ---
 
-Whoa! You'll notice we just cleaned up the code to the right, and you now have tabs at the top of your editor. Go ahead, click between the tabs to try it out.
+Зацени! Мы снесли код справа, и теперь у тебя есть вкладки в верхней части редактора. Вперед, попереключайся между вкладками, чтобы попробовать. 
 
-Our code was getting pretty long, so we split it up into multiple files to make it more manageable. This is normally how you will handle long codebases in your Solidity projects.
+Код уже довольно длинный, поэтому мы разбили его на несколько файлов, чтобы сделать его более послушным. Именно так управляют длинным кодом в проектах Solidity. 
 
-When you have multiple files and you want to import one file into another, Solidity uses the `import` keyword:
+Когда у тебя несколько файлов и нужно импортировать один в другой, Solidity использует ключевое слово `import`:
 
 ```
 import "./someothercontract.sol";
@@ -77,10 +77,10 @@ contract newContract is SomeOtherContract {
 }
 ```
 
-So if we had a file named `someothercontract.sol` in the same directory as this contract (that's what the `./` means), it would get imported by the compiler.
+Если у нас есть файл `someothercontract.sol` в той же директории, что и этот контракт (`/` нам говорит об этом), то компилятор инпортирует его.
 
-# Put it to the test
+# Проверь себя
 
-Now that we've set up a multi-file structure, we need to use `import` to read the contents of the other file:
+Теперь, когда у нас мульфайловая структура, воспользуемся `import` для чтения содержимого другого файла:
 
-1. Import `zombiefactory.sol` into our new file, `zombiefeeding.sol`. 
+1. Импортируй `zombiefactory.sol` в новый файл `zombiefeeding.sol`. 
diff --git a/cryptozombie-lessons_ru/ru/2/7-storage.md b/cryptozombie-lessons_ru/ru/2/7-storage.md
index cae0b7d..30b440b 100644
--- a/cryptozombie-lessons_ru/ru/2/7-storage.md
+++ b/cryptozombie-lessons_ru/ru/2/7-storage.md
@@ -1,6 +1,6 @@
 ---
-title: Storage vs Memory
-actions: ['checkAnswer', 'hints']
+title: Хранилище и память
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -12,7 +12,7 @@ material:
 
         contract ZombieFeeding is ZombieFactory {
 
-          // Start here
+          // Начало здесь
 
         }
       "zombiefactory.sol": |
@@ -69,13 +69,13 @@ material:
       }
 ---
 
-In Solidity, there are two places you can store variables — in `storage` and in `memory`.
+В Solidity есть два места, где могут сохраняться переменные: в `storage` (хранилище) и в `memory` (памяти).
 
-**_Storage_** refers to variables stored permanently on the blockchain. **_Memory_** variables are temporary, and are erased between external function calls to your contract. Think of it like your computer's hard disk vs RAM.
+**_Хранилище_** используют, чтобы сохранить переменные в блокчейн навсегда. **_Память_** используют для временного хранения переменных, они стираются в промежутках, когда внешняя функция обращается к контракту. Это похоже на жесткий диск компьютера и оперативную память. 
 
-Most of the time you don't need to use these keywords because Solidity handles them by default. State variables (variables declared outside of functions) are by default `storage` and written permanently to the blockchain, while variables declared inside functions are `memory` and will disappear when the function call ends.
+В большинстве случаев тебе не придется использовать ключевые слова, потому что Solidity определяет по умолчанию, что куда сохранять. Переменные состояния (заданные вне функции) по умолчанию хранятся записанными в блокчейне. Переменные, заданные внутри функции, пишутся в память и исчезнут, как только вызов функции закончится. 
 
-However, there are times when you do need to use these keywords, namely when dealing with **_structs_** and **_arrays_** within functions:
+Тем не менее, есть случаи, когда обязательно надо указывать ключевые слова, а именно когда ты работаешь со **_структурами_** и **_массивами_** в пределах функции: 
 
 ```
 contract SandwichFactory {
@@ -87,49 +87,47 @@ contract SandwichFactory {
   Sandwich[] sandwiches;
 
   function eatSandwich(uint _index) public {
-    // Sandwich mySandwich = sandwiches[_index];
+    // Сэндвич mySandwich = sandwiches[_index];
 
-    // ^ Seems pretty straightforward, but solidity will give you a warning
-    // telling you you should explicitly declare `storage` or `memory` here.
+    // ^ Вроде все в порядке, но Solidity выдаст предупреждение, 
+    // что надо ясно указать `storage` или `memory`.
 
-    // So instead, you should declare with the `storage` keyword, like:
+    // Поэтому используй ключевое слово `storage`, вот так: 
     Sandwich storage mySandwich = sandwiches[_index];
-    // ...in which case `mySandwich` is a pointer to `sandwiches[_index]`
-    // in storage, and...
+    // ...где `mySandwich` указывает на `sandwiches[_index]` в хранилище, и...
     mySandwich.status = "Eaten!";
-    // ...this will permanently change `sandwiches[_index]` on the blockchain.
+    // ...навсегда изменит `sandwiches[_index]` в блокчейне.
 
-    // If you just want a copy, you can use `memory`:
+    // Если нужна просто копия, используй `memory`:
     Sandwich memory anotherSandwich = sandwiches[_index + 1];
-    // ...in which case `anotherSandwich` will simply be a copy of the 
-    // data in memory, and...
+    // ...тогда `anotherSandwich` будет простой копией данных в памяти, таким образом... 
     anotherSandwich.status = "Eaten!";
-    // ...will just modify the temporary variable and have no effect 
-    // on `sandwiches[_index + 1]`. But you can do this:
+    // ...всего лишь модифицирует временную переменную и не окажет влияния
+    // на `sandwiches[_index + 1]`. Но ты можешь сделать и так... 
     sandwiches[_index + 1] = anotherSandwich;
-    // ...if you want to copy the changes back into blockchain storage.
+    // ...если надо сохранить данные в блокчейне.
   }
 }
 ```
 
-Don't worry if you don't fully understand when to use which one yet — throughout this tutorial we'll tell you when to use `storage` and when to use `memory`, and the Solidity compiler will also give you warnings to let you know when you should be using one of these keywords.
+Не волнуйся, если пока не все ясно — на протяжение курса мы подскажем, когда использовать `storage`, а когда ` memory`. Компилятор Solidity тоже выдает предупреждение, когда нужно использовать одно из этих ключевых слов.
 
-For now, it's enough to understand that there are cases where you'll need to explicitly declare `storage` or `memory`!
+На данный момент достаточно принять как факт, что есть случаи, требующие ясного обозначения `storage` или `memory`! 
 
-# Put it to the test
+# Проверь себя
 
-It's time to give our zombies the ability to feed and multiply!
+Время наделить твоего зомби спобностью питаться и размножаться! 
 
-When a zombie feeds on some other lifeform, its DNA will combine with the other lifeform's DNA to create a new zombie.
+Когда зомби пожирает другую форму жизни, его ДНК объединяется с ДНК другой жизнеформы и получается новый зомби. 
 
-1. Create a function called `feedAndMultiply`. It will take two parameters: `_zombieId` (a `uint`) and `_targetDna` (also a `uint`). This function should be `public`.
+1. Создай функцию под названием `feedAndMultiply`. Она берет два параметра: `_zombieId` (`uint`) и `_targetDna` (тоже `uint`). Сделай функцию открытой `public`.
 
-2. We don't want to let someone else feed using our zombie! So first, let's make sure we own this zombie. Add a `require` statement to make sure `msg.sender` is equal to this zombie's owner (similar to how we did in the `createRandomZombie` function).
+2. Мы не хотим, чтобы наших зомби жрал кто-то еще! Убедимся, что зомби и вправду принадлежит нам. Добавь оператор `require` (требуется), чтобы убедиться, что `msg.sender` (отправитель) тот же, что и владелец зомби (точно так же, как мы делали в функции `createRandomZombie`).
 
- > Note: Again, because our answer-checker is primitive, it's expecting `msg.sender` to come first and will mark it wrong if you switch the order. But normally when you're coding, you can use whichever order you prefer — both are correct.
+ > Обрати внимание: из-за того, что наша проверялка довольна примитивна, ожидается, что `msg.sender` идет первым и если поменять порядок, то вылетит ошибка. Но вообще когда кодишь, можно использовать любой порядок — оба правильные.
 
-3. We're going to need to get this zombie's DNA. So the next thing our function should do is declare a local `Zombie` named `myZombie` (which will be a `storage` pointer). Set this variable to be equal to index `_zombieId` in our `zombies` array.
+3. Нам нужно получить ДНК этого зомби. Следующее действие функции - задать локального `Zombie` под названием `myZombie` (который будет указателем в `storage`). Установи эту переменную равной индексу `_zombieId` в нашем массиве` zombies`.
 
-You should have 4 lines of code so far, including the line with the closing `}`. 
+У тебя должно получить 4 строчки кода, включая закрывающую скобку `}`. 
 
-We'll continue fleshing out this function in the next chapter!
+Доведем до ума эту функцию в следующей главе!
diff --git a/cryptozombie-lessons_ru/ru/2/8-feedandmultiply2.md b/cryptozombie-lessons_ru/ru/2/8-feedandmultiply2.md
index fd97dad..a461cd6 100644
--- a/cryptozombie-lessons_ru/ru/2/8-feedandmultiply2.md
+++ b/cryptozombie-lessons_ru/ru/2/8-feedandmultiply2.md
@@ -1,6 +1,6 @@
 ---
-title: Zombie DNA
-actions: ['checkAnswer', 'hints']
+title: ДНК Зомби 
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -15,7 +15,7 @@ material:
           function feedAndMultiply(uint _zombieId, uint _targetDna) public {
             require(msg.sender == zombieToOwner[_zombieId]);
             Zombie storage myZombie = zombies[_zombieId];
-            // start here
+            // Начало здесь
           }
 
         }
@@ -76,31 +76,31 @@ material:
       }
 ---
 
-Let's finish writing the `feedAndMultiply` function.
+Давайте допишем функицию `feedAndMultiply` (питаться и размножаться).
 
-The formula for calculating a new zombie's DNA is simple: It's simply that average between the feeding zombie's DNA and the target's DNA. 
+Формула вычиления ДНК нового зомби проста: среднее значение между ДНК охотника и ДНК жертвы.
 
-For example:
+Пример:
 
 ```
 function testDnaSplicing() public {
   uint zombieDna = 2222222222222222;
   uint targetDna = 4444444444444444;
   uint newZombieDna = (zombieDna + targetDna) / 2;
-  // ^ will be equal to 3333333333333333
+  // ^ будет равно 3333333333333333
 }
 ```
 
-Later we can make our formula more complicated if we want to, like adding some randomness to the new zombie's DNA. But for now we'll keep it simple — we can always come back to it later.
+При желании позже можно усложнить формулу, добавить элемент случайности в ДНК нового зомби. Но пока можно оставить так, вернуться к этому мы всегда успеем.
 
-# Put it to the test
+# Проверь себя
 
-1. First we need to make sure that `_targetDna` isn't longer than 16 digits. To do this, we can set `_targetDna` equal to `_targetDna % dnaModulus` to only take the last 16 digits.
+1. Первым делом нам нужно убедиться, что `_targetDna` не длиннее, чем 16 цифр. Для этого зададим `_targetDna` равной `_targetDna % dnaModulus`, чтобы взять только последние 16 цифр.  
 
-2. Next our function should declare a `uint` named `newDna`, and set it equal to the average of `myZombie`'s DNA and `_targetDna` (as in the example above).
+2. Затем функция должна задать `uint` под названием `newDna` и приравнять ее к среднему значению между ДНК `myZombie` и `_targetDna` (как в примере выше). 
 
-  > Note: You can access the properties of `myZombie` using `myZombie.name` and `myZombie.dna`
+  > Обрати внимание: чтобы получить доступ к свойствам `myZombie`, используй `myZombie.name` и `myZombie.dna`
 
-3. Once we have the new DNA, let's call `_createZombie`. You can look at the `zombiefactory.sol` tab if you forget which parameters this function needs to call it. Note that it requires a name, so let's set our new zombie's name to `"NoName"` for now — we can write a function to change zombies' names later.
+3. Как только мы получим новую ДНК, вызовем `_createZombie`. Можешь посмотреть во вкладке `zombiefactory.sol`, если забыли, какие параметры нужны функции для вызова ее. Обрати внимание, что ей нужно имя, поэтому пока установим имя зомби `"NoName"` — потом можно дописать функцию изменения имени зомби.
 
-> Note: For you Solidity whizzes, you may notice a problem with our code here! Don't worry, we'll fix this in the next chapter ;)
+> Внимание: видишь ошибку в коде? Не беспокойся, мы исправим ее в следующей главе;) 
diff --git a/cryptozombie-lessons_ru/ru/2/9-internalfunctions.md b/cryptozombie-lessons_ru/ru/2/9-internalfunctions.md
index aac87be..007fe70 100644
--- a/cryptozombie-lessons_ru/ru/2/9-internalfunctions.md
+++ b/cryptozombie-lessons_ru/ru/2/9-internalfunctions.md
@@ -1,6 +1,6 @@
 ---
-title: More on Function Visibility
-actions: ['checkAnswer', 'hints']
+title: Еще насчет видимости функций
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -25,7 +25,7 @@ material:
             mapping (uint => address) public zombieToOwner;
             mapping (address => uint) ownerZombieCount;
 
-            // edit function definition below
+            // Редактировать значение функции ниже
             function _createZombie(string _name, uint _dna) private {
                 uint id = zombies.push(Zombie(_name, _dna)) - 1;
                 zombieToOwner[id] = msg.sender;
@@ -102,21 +102,21 @@ material:
       }
 ---
 
-**The code in our previous lesson has a mistake!**
+**Код в предыдущем уроке содержал ошибку!**
 
-If you try compiling it, the compiler will throw an error.
+Если ты попробуешь его скомпилировать, то компилятор выдаст ошибку. 
 
-The issue is we tried calling the `_createZombie` function from within `ZombieFeeding`, but `_createZombie` is a `private` function inside `ZombieFactory`. This means none of the contracts that inherit from `ZombieFactory` can access it.
+Дело в том, что мы пытались вызвать функцию `_createZombie` в пределах `ZombieFeeding`, но `_createZombie` — закрытая функция внутри `ZombieFactory`. Это значит, что никакой контракт, который наследует `ZombieFactory`, не может получить туда доступ. 
 
-## Internal and External
+## Внутренние и внешние функции
 
-In addition to `public` and `private`, Solidity has two more types of visibility for functions: `internal` and `external`.
+В дополнение к открытым и закрытым, в Solidity есть еще два типа видимости для функций: `internal` (внутренняя) и `external` (внешняя). 
 
-`internal` is the same as `private`, except that it's also accessible to contracts that inherit from this contract. **(Hey, that sounds like what we want here!)**.
+`internal` (внутренняя) это почти как `private` (закрытая), разница лишь в том, что к нему могут получить доступ только контракты, которые наследуют этому контракту. **(Звучит как полная ерунда!)**.
 
-`external` is similar to `public`, except that these functions can ONLY be called outside the contract — they can't be called by other functions inside that contract. We'll talk about why you might want to use `external` vs `public` later.
+`external` (внешний) это как `public` (открытая), с той лишь разницей, что она может быть вызвана ТОЛЬКО за пределами контракта — другими функциями вне его. Позже поговорим о том, когда использовать `external` а когда `public` функции.
 
-For declaring `internal` or `external` functions, the syntax is the same as `private` and `public`:
+Для `internal` или `external` функций синтаксис такой же, как в `private` and `public`:
 
 ```
 contract Sandwich {
@@ -132,14 +132,14 @@ contract BLT is Sandwich {
 
   function eatWithBacon() public returns (string) {
     baconSandwichesEaten++;
-    // We can call this here because it's internal
+    // Можно вызвать функцию, потому что она внутренняя
     eat();
   }
 }
 ```
 
-# Put it to the test
+# Проверь себя
 
-1. Change `_createZombie()` from `private` to `internal` so our other contract can access it.
+1. Измени функцию `_createZombie()` с `private` (открытой) на `internal` (внутреннюю), чтобы сделать ее доступной для других контрактов.
 
-  We've already focused you back to the proper tab, `zombiefactory.sol`.
+  Вернись во вкладку `zombiefactory.sol`.
diff --git a/cryptozombie-lessons_ru/ru/2/template.md b/cryptozombie-lessons_ru/ru/2/template.md
index 4f58c99..f870421 100644
--- a/cryptozombie-lessons_ru/ru/2/template.md
+++ b/cryptozombie-lessons_ru/ru/2/template.md
@@ -1,6 +1,6 @@
 ---
-title: Data Types
-actions: ['checkAnswer', 'hints']
+title: Типы данных
+actions: ['Проверить', 'Подсказать']
 material:
   editor:
     language: sol
@@ -8,12 +8,12 @@ material:
     answer: >
 ---
 
-Solidity's code is encapsulated in contracts. A contract is basically...
+Код в Solidity помещают внутри **контрактов**. `contract` — это просто...
 
 ```
 contract HelloWorld
 
 ```
 
-# Put it to the test
+# Проверь себя
 
diff --git a/cryptozombie-lessons_ru/ru/3/00-overview.md b/cryptozombie-lessons_ru/ru/3/00-overview.md
index cec5c59..981106c 100644
--- a/cryptozombie-lessons_ru/ru/3/00-overview.md
+++ b/cryptozombie-lessons_ru/ru/3/00-overview.md
@@ -1,15 +1,15 @@
 ---
-title: Advanced Solidity Concepts
-header: "Lesson 3: Advanced Solidity Concepts"
+title: Продвинутые концепции Solidity 
+header: "Урок 3: Продвинутые концепции Concepts"
 roadmap: roadmap3.png
 ---
 
-Grr... I just can't slow you down, can I? Your Solidity skills are formidable, human...
+Грррр... Да тебя не остановить, человек! Твой Solidity становится по настоящему опасным...
 
-Now that you've got some experience coding Solidity under your belt, we're going to dive into some of the more technical aspects of Ethereum development.
+Теперь, когда у тебя в запасе есть опыт кода Solidity, давай погрузимся в более технические аспекты разработки Ethereum.
 
-This lesson will be a bit less flashy (sorry, no plot twists!). But you’ll learn some really important concepts that will take you closer to building real DApps — things like **contract ownership, gas costs, code optimization, and security**.
+Этот урок будет не такой яркий (сюжет буксует). Зато ты научишься действительно важным аспектам, которые приблизят тебя к построению настоящих DApps (децентрализованных приложений) — например **принадлежность контрактов, стоимость газа, оптимизация кода и безопасность**.
 
-You've been warned — no kitties and rainbows in Lesson 3!
+Мы тебя предупредили — ни котиков, ни радужных единорогов в Уроке 3!
 
-But a lot of densely-packed Solidity knowledge. We strongly recommended that you complete Lesson 2 before starting this one.
+Зато много плотно упакованных знаний Solidity. Настоятельно рекомендуем закончить Урок 2, перед тем как приступить к третьему.
diff --git a/cryptozombie-lessons_ru/ru/3/01-externaldependencies.md b/cryptozombie-lessons_ru/ru/3/01-externaldependencies.md
index afb34ea..cc19ed9 100644
--- a/cryptozombie-lessons_ru/ru/3/01-externaldependencies.md
+++ b/cryptozombie-lessons_ru/ru/3/01-externaldependencies.md
@@ -1,6 +1,6 @@
 ---
-title: Immutability of Contracts
-actions: ['checkAnswer', 'hints']
+title: Неизменяемость контрактов
+actions: ['Проверить', 'Подсказать']
 requireLogin: true
 material:
   editor:
diff --git a/cryptozombie-lessons_ru/ru/3/03-onlyowner.md b/cryptozombie-lessons_ru/ru/3/03-onlyowner.md
index 6e92147..f5df5ff 100644
--- a/cryptozombie-lessons_ru/ru/3/03-onlyowner.md
+++ b/cryptozombie-lessons_ru/ru/3/03-onlyowner.md
@@ -1,6 +1,6 @@
 ---
-title: onlyOwner Function Modifier
-actions: ['checkAnswer', 'hints']
+title: Модификатор функции onlyOwner (единственный владелец)
+actions: ['Проверить', 'Подсказать']
 requireLogin: true
 material:
   editor:
@@ -30,7 +30,7 @@ material:
 
           KittyInterface kittyContract;
 
-          // Modify this function:
+          // Модифицируй функцию:
           function setKittyContractAddress(address _address) external {
             kittyContract = KittyInterface(_address);
           }
@@ -183,22 +183,24 @@ material:
       }
 ---
 
-Now that our base contract `ZombieFactory` inherits from `Ownable`, we can use the `onlyOwner` function modifier in `ZombieFeeding` as well.
+Теперь наш базовый контракт `ZombieFactory` наследует от `Ownable` и мы можем использовать модификатор `onlyOwner` в `ZombieFeeding`. Now that our base contract `ZombieFactory` inherits from `Ownable`, we can use the `onlyOwner` function modifier in `ZombieFeeding` as well.
 
-This is because of how contract inheritance works. Remember:
+Так работает наследование в контрактах. Запомни:
 
 ```
 ZombieFeeding is ZombieFactory
 ZombieFactory is Ownable
 ```
 
-Thus `ZombieFeeding` is also `Ownable`, and can access the functions / events / modifiers from the `Ownable` contract. This applies to any contracts that inherit from `ZombieFeeding` in the future as well.
+Таким образом, `ZombieFeeding` также и `Ownable`, он может получить доступ к функциям / событиям / модификаторам из контракта `Ownable`. Это относится к любым контрактам, которые будут наследовать `ZombieFeeding` в будущем.
 
-## Function Modifiers
+## Модификаторы функций
 
-A function modifier looks just like a function, but uses the keyword `modifier` instead of the keyword `function`. And it can't be called directly like a function can — instead we can attach the modifier's name at the end of a function definition to change that function's behavior.
+Модификатор функции выглядит точно так же, как функция, но использует ключевое слово `modifier` вместо `function`. Его нельзя вызвать напрямую, как функцию - вместо этого добавить модификатор в конце определения функции и изменить поведение функции.
 
-Let's take a closer look by examining `onlyOwner`:
+A function modifier looks just like a function, but uses the keyword `modifier` instead of the keyword `function`. And it can't be called directly like a function can — instead we can attach the modifier's name at the end of a function definition to change that functions behavior.
+
+Посмотрим внимательныее на примере `onlyOwner`:
 
 ```
 /**
@@ -216,25 +218,32 @@ We would use this modifier as follows:
 contract MyContract is Ownable {
   event LaughManiacally(string laughter);
 
-  // Note the usage of `onlyOwner` below:
+  // Обрати внаминае на использование `onlyOwner` ниже:
   function likeABoss() external onlyOwner {
     LaughManiacally("Muahahahaha");
   }
 }
 ```
 
+Видишь модификатор `onlyOwner` в функции `likeABoss`? Когда ты вызываешь `likeABoss`, код внутри `onlyOwner` выполняется **в первую очередь**. Затем, когда он доходит до оператора `_;` в `onlyOwner`, он возвращается и выполняет код внутри `likeABoss`.
+
 Notice the `onlyOwner` modifier on the `likeABoss` function. When you call `likeABoss`, the code inside `onlyOwner` executes **first**. Then when it hits the `_;` statement in `onlyOwner`, it goes back and executes the code inside `likeABoss`.
 
+Хотя есть и другие способы использования модификаторов, одним из наиболее распространенных вариантов использования является добавление быстрой проверки `require` перед выполнением функции.
 So while there are other ways you can use modifiers, one of the most common use-cases is to add quick `require` check before a function executes.
 
+В случае `onlyOwner`, добавление этого модификатора в функцию делает так, что только **единственный владелец**, например ты, может вызвать эту функцию.
 In the case of `onlyOwner`, adding this modifier to a function makes it so **only** the **owner** of the contract (you, if you deployed it) can call that function.
 
+> Обрати внимание: предоставление владельцу особой власти над подобным контрактом часто необходимо. Но этим могут злоупотреблять. Например, владелец может добавить бэкдор, который переведет всех зомби на его адрес!
 >Note: Giving the owner special powers over the contract like this is often necessary, but it could also be used maliciously. For example, the owner could add a backdoor function that would allow him to transfer anyone's zombies to himself!
 
->So it's important to remember that just because a DApp is on Ethereum does not automatically mean it's decentralized — you have to actually read the full source code to make sure it's free of special controls by the owner that you need to potentially worry about. There's a careful balance as a developer between maintaining control over a DApp such that you can fix potential bugs, and building an owner-less platform that your users can trust to secure their data.
+> Важно помнить, что DApp на Ethereum не означает автоматически децентрализацию. Читай исходники полностью, чтобы убедиться, что он чист от средств передачи контроля другому владельцу. Для разработчика это нахождение баланса междуконтролем над DApp для исправления ошибок, и созданием платформы без владельца, которой ваши пользователи могут доверять, чтобы защитить свои данные.
+>
+So it's important to remember that just because a DApp is on Ethereum does not automatically mean it's decentralized — you have to actually read the full source code to make sure it's free of special controls by the owner that you need to potentially worry about. There's a careful balance as a developer between maintaining control over a DApp such that you can fix potential bugs, and building an owner-less platform that your users can trust to secure their data.
 
-## Put it to the test
+## Проверь себя
 
-Now we can restrict access to `setKittyContractAddress` so that no one but us can modify it in the future.
+Теперь мы можем запретить доступ к `setKittyContractAddress` чтобы никто не могу его изменить в будущем.
 
-1. Add the `onlyOwner` modifier to `setKittyContractAddress`.
+1. Добавь модификатор `onlyOwner` к `setKittyContractAddress`.
diff --git a/cryptozombie-lessons_ru/ru/3/04-gas.md b/cryptozombie-lessons_ru/ru/3/04-gas.md
index d2bd19a..205fe38 100644
--- a/cryptozombie-lessons_ru/ru/3/04-gas.md
+++ b/cryptozombie-lessons_ru/ru/3/04-gas.md
@@ -1,6 +1,6 @@
 ---
-title: Gas
-actions: ['checkAnswer', 'hints']
+title: Газ
+actions: ['Проверить', 'Подсказать']
 requireLogin: true
 material:
   editor:
@@ -21,7 +21,7 @@ material:
             struct Zombie {
                 string name;
                 uint dna;
-                // Add new data here
+                // Здесь добавь новые данные
             }
 
             Zombie[] public zombies;
@@ -179,35 +179,45 @@ material:
       }
 ---
 
-Great! Now we know how to update key portions of the DApp while preventing other users from messing with our contracts.
+Круто! Теперь мы знаем, как обновлять ключевые части DApp, при этом заставляя других пользователей держаться подальше от наших контрактов, чтобы не испортили. Now we know how to update key portions of the DApp while preventing other users from messing with our contracts.
 
-Let's look at another way Solidity is quite different from other programming languages:
+Давай посмотрим на еще одно серьезное отличие Solidity от других языков программирования:
 
-## Gas — the fuel Ethereum DApps run on
+## Газ — это топливо для DApps на Ethereum
 
-In Solidity, your users have to pay every time they execute a function on your DApp using a currency called **_gas_**. Users buy gas with Ether (the currency on Ethereum), so your users have to spend ETH in order to execute functions on your DApp. 
+В Solidity пользователи должны заплатить за каждый раз, когда они вызывают функцию вашего DApp, с помощью валюты под названием ** _газ_ **. Газ покупают вместе с эфиром, валютой Ethereum, таким образом пользователи платят ETH, чтобы выполнить функцию приложения DApp.In Solidity, your users have to pay every time they execute a function on your DApp using a currency called **_gas_**. Users buy gas with Ether (the currency on Ethereum), so your users have to spend ETH in order to execute functions on your DApp. 
+
+Количество газа для выполнения функции зависит от сложности логики функции. У любой операции есть **_стоимость газа_**, она основана на количестве вычислительных ресурсов, необходимых для выполнения  операции (например, запись в хранилище намного дороже, чем добавление двух целых чисел). Общая **_стоимость газа_** вашей функции - сумма затрат газа на все операции.
 
 How much gas is required to execute a function depends on how complex that function's logic is. Each individual operation has a **_gas cost_** based roughly on how much computing resources will be required to perform that operation (e.g. writing to storage is much more expensive than adding two integers). The total **_gas cost_** of your function is the sum of the gas costs of all its individual operations.
 
+Поскольку запуск функций стоит реальных денег пользователям, оптимизация кода гораздо важнее в Ethereum, чем в других языках программирования. Если код написан небрежно, а пользователям придется платить за выполнение функций, в пересчете на тысячи пользователей это может означать миллионы долларов ненужных комиссий.
+
 Because running functions costs real money for your users, code optimization is much more important in Ethereum than in other programming languages. If your code is sloppy, your users are going to have to pay a premium to execute your functions — and this could add up to millions of dollars in unnecessary fees across thousands of users.
 
-## Why is gas necessary?
+## Зачем нужен газ?
+
+Ethereum похож на большой, медленный, но крайне безопасный компьютер. Когда ты выполняешь функцию, каждая нода в сети должна запустить ту же самую функцию проверки результата на выходе. Это то, что делает Ethereum децентрализованным, а данные в нем неизменяемыми а не подверженными цензуре.
 
 Ethereum is like a big, slow, but extremely secure computer. When you execute a function, every single node on the network needs to run that same function to verify its output — thousands of nodes verifying every function execution is what makes Ethereum decentralized, and its data immutable and censorship-resistant.
 
+Создатели Ethereum хотели быть уверенными, что никто не сможет заспамить сеть, запустив бесконечный цикл, или сожрать все сетевые ресурсы интенсивными вычислениями. Поэтому они сделали транзакции платными — пользователи должны платить за использование вычислительных мощностей и за хранение.
+
 The creators of Ethereum wanted to make sure someone couldn't clog up the network with an infinite loop, or hog all the network resources with really intensive computations. So they made it so transactions aren't free, and users have to pay for computation time as well as storage.
 
+> Обрати внимание. Для сайдчейнов, как например для того, который авторы КриптоЗомби используют в Loom Network, это правило не обязательно. Нет смысла запускать игру вроде World of Warcraft в главной сети Ethereum - стоимость газа будет реальным барьером. Но зато такая игра может работать на сайдчейне с другим алгоритмом консенсус. В следующих уроках мы вернемся к тому, какие DApps развертывать на сайдчейне, а какие в главной сети Ethereum.
+
 > Note: This isn't necessarily true for sidechains, like the ones the CryptoZombies authors are building at Loom Network. It probably won't ever make sense to run a game like World of Warcraft directly on the Ethereum mainnet — the gas costs would be prohibitively expensive. But it could run on a sidechain with a different consensus algorithm. We'll talk more about what types of DApps you would want to deploy on sidechains vs the Ethereum mainnet in a future lesson.
 
-## Struct packing to save gas
+## Как упаковать структуру, чтобы сэкономить газ
 
-In Lesson 1, we mentioned that there are other types of `uint`s: `uint8`, `uint16`, `uint32`, etc.
+Мы упоминали в первом уроке, что есть разные типы `uint`: `uint8`,` uint16`, `uint32` и так далее. 
 
-Normally there's no benefit to using these sub-types because Solidity reserves 256 bits of storage regardless of the `uint` size. For example, using `uint8` instead of `uint` (`uint256`) won't save you any gas.
+Обычно использование этих подтипов нецелесообразно, поскольку Solidity резервирует 256 бит в хранилище независимо от размера `uint`. Например, использование `uint8` вместо `uint` (`uint256`) не экономит газ.
 
-But there's an exception to this: inside `struct`s.
+Но есть и исключение внутри структур.
 
-If you have multiple `uint`s inside a struct, using a smaller-sized `uint` when possible will allow Solidity to pack these variables together to take up less storage. For example:
+Если внутри структуры несколько `uint`, использование по возможности `uint` меньшего размера позволит Solidity объединить переменные вместе и уменьшить объем хранилища. Например:
 
 ```
 struct NormalStruct {
@@ -222,25 +232,21 @@ struct MiniMe {
   uint c;
 }
 
-// `mini` will cost less gas than `normal` because of struct packing
+// `mini` будет стоить меньше, чем `normal` из-за упаковки структуры
 NormalStruct normal = NormalStruct(10, 20, 30);
 MiniMe mini = MiniMe(10, 20, 30); 
 ```
 
-For this reason, inside a struct you'll want to use the smallest integer sub-types you can get away with.
-
-You'll also want to cluster identical data types together (i.e. put them next to each
-other in the struct) so that Solidity can minimize the required storage space. For example, a struct with
-fields `uint c; uint32 a; uint32 b;` will cost less gas than a struct with fields `uint32 a; uint c; uint32 b;`
-because the `uint32` fields are clustered together.
+Так что внутри структур можешь использовать наименьшие целочисленные подтипы, которые позволяют запустить код.
 
+Еще можно объединить в кластеры идентичные типы данных, то есть поставить их в структуре рядом друг с другом. Так Solidity оптимизирует требующееся пространство в хранилище. К примеру, структура поля `uint c; uint32 a; uint32 b;` будет стоить меньше газа, чем структура с полями `uint32 a; uint c; uint32 b;`, потому что поля `uint32` группируются вместе.
 
-## Put it to the test
+## Проверь себя
 
-In this lesson, we're going to add 2 new features to our zombies: `level` and `readyTime` — the latter will be used to implement a cooldown timer to limit how often a zombie can feed. 
+В этом уроке мы собираемся добавить зомби 2 новые фишки: `level` (уровень) и `readyTime` (время готовности) — послдняя будет использоваться для установки времени восстановления, чтобы ограничить частоту питания зомби. 
 
-So let's jump back to `zombiefactory.sol`.
+Вернемся назад к `zombiefactory.sol`.
 
-1. Add two more properties to our `Zombie` struct: `level` (a `uint32`), and `readyTime` (also a `uint32`). We want to pack these data types together, so let's put them at the end of the struct.
+1. Добавь еще два свойства к структуре `Zombie`: `level` (`uint32`) и `readyTime` (тоже `uint32`). Мы хотим объединить эти типы данных, давай поместим их в конец структуры.
 
-32 bits is more than enough to hold the zombie's level and timestamp, so this will save us some gas costs by packing the data more tightly than using a regular `uint` (256-bits).
+32 бита достаточно для хранения уровня и времени восстановления зомби. Мы сэкономили немного газа, упаковав данные поплотнее, чем обычный 256-битный `uint`.
diff --git a/cryptozombie-lessons_ru/ru/3/13-wrappingitup.md b/cryptozombie-lessons_ru/ru/3/13-wrappingitup.md
index 833a8e3..8d2312e 100644
--- a/cryptozombie-lessons_ru/ru/3/13-wrappingitup.md
+++ b/cryptozombie-lessons_ru/ru/3/13-wrappingitup.md
@@ -1,6 +1,6 @@
 ---
-title: Wrapping It Up
-actions: ['checkAnswer', 'hints']
+title: Подведем итог
+actions: ['Проверить', 'Подсказать']
 requireLogin: true
 material:
   saveZombie: false
@@ -11,21 +11,21 @@ material:
     answer: 1
 ---
 
-Congratulations! That concludes Lesson 3.
+Наши поздравления! Урок 3 завершен.
 
-## Let's recap:
+## Напомним:
 
-- We've added a way to update our CryptoKitties contracts
-- We've learned to protect core functions with `onlyOwner`
-- We've learned about gas and gas optimization
-- We added levels and cooldowns to our zombies
-- We now have functions to update a zombie's name and DNA once the zombie gets above a certain level
-- And finally, we now have a function to return a user's zombie army
+- Мы добавили способ обновления контракта Криптокотиков We've added a way to update our CryptoKitties contracts
+- Мы научились защищать основные функции с помощью `onlyOwner`
+- Мы узнали о газе и его оптимизации
+- Добавили уровни и кулдауны для наших зомби We added levels and cooldowns to our zombies
+- Сейчас у нас есть функция изменения имени и ДНК, когда зомби достигент определенного уровня We now have functions to update a zombie's name and DNA once the zombie gets above a certain level
+- И, наконец, теперь у нас есть функция возврата зомби-армии пользователю And finally, we now have a function to return a user's zombie army
 
-## Claim your reward
+## Тебе положен подарок
 
-As a reward for completing Lesson 3, both of your zombies have leveled up!
+Как вознаграждение за завершение Урока 3, оба твоих зомби повышены уровнем! As a reward for completing Lesson 3, both of your zombies have leveled up!
 
-And now that NoName (the kitty-zombie you created in Lesson 2), is upgraded to level 2, you can call `changeName` to give him/her a name. NoName no more!
+И теперь, когда безымянный зомбокотик из урока 2 получил уровень, ты можешь вызвать `changeName` и назвать его так, как хочешь. Хватит ноунеймов!  And now that NoName (the kitty-zombie you created in Lesson 2), is upgraded to level 2, you can call `changeName` to give him/her a name. NoName no more!
 
-Go ahead and give NoName a name, then proceed to the next chapter to complete the lesson.
+Вперед! Дай имя зомби и двигайся к следующему разделу, чтобы закончить урок. Go ahead and give NoName a name, then proceed to the next chapter to complete the lesson.
diff --git a/cryptozombie-lessons_ru/ru/3/14-lessoncomplete.md b/cryptozombie-lessons_ru/ru/3/14-lessoncomplete.md
index ba603dc..95ff625 100644
--- a/cryptozombie-lessons_ru/ru/3/14-lessoncomplete.md
+++ b/cryptozombie-lessons_ru/ru/3/14-lessoncomplete.md
@@ -1,6 +1,6 @@
 ---
-title: Lesson 3 Complete!
-actions: ['checkAnswer', 'hints']
+title: Урок 3 завершен!
+actions: ['Проверить', 'Подсказать']
 material:
   lessonComplete:
     answer: 1